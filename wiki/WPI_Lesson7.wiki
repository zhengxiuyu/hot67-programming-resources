#summary Sensors and Information

Now that you know how to make the robot move, now it is time to make it move intelligently. However, this can't be done without some sort of indication of the robot's state. This is what sensors are for.

This lesson will discuss how to obtain values from the various sensors on the robot.

<wiki:toc max_depth="2">

=Providing Information=

Sensors are useless if you can't get a reading from them. While this can be done in the code, you still need hard values from the sensors in order to do anything with them. So, you need to find a way to print this data to the screen.

There are two ways to do this: through the driver station and through !SmartDashboard.

==Driver Station==

You already know how to do this. Simply inject the data into a [WPI_Lesson4#Printing_to_the_Driver_Station Printf()] statement.

{{{
m_dsLCD->Printf(DriverStationLCD::kUserLine1,1,"Sensor Value: %f",m_sensorValue);
}}}

==!SmartDashboard==

The other way is to use an application called !SmartDashboard. !SmartDashboard is a program designed to provide data from the robot. It is the C++/Java equivalent of the FRC Dashboard. It also provides a function called [WPI_Lesson3#Live_Window live window mode], which you may remember from lesson 3.

However, how you print data to !SmartDashboard is quite different than how you print data to the driver station. As a matter of fact, an object for !SmartDashboard is not even required to do so.

What you do depends on the type of variable you want to display on !SmartDashboard.

{{{
void SmartDashboard::PutNumber(const char* name, double value)
void SmartDashboard::PutBoolean(const char* name, bool value)
}}}

===!SmartDashboard parameters===

  * `const char* name`: Name/identifier of the variable in !SmartDashboard.
  * `value`: The variable.
  
===!SmartDashboard use===

Because there is no object (outside of Live Window) that is required to manage !SmartDashboard, so when you want to call these functions, you need to include the `SmartDashboard::` prefix in order for your code to compile.

{{{
//PutNumber example
SmartDashboard::PutNumber("Sensor Value: ",m_sensorValue);
}}}

=Reading from Sensors=

|| *(!) The following section is incomplete.* ||
|| _Reason: Reading from all sensors_ ||
|| You can help by *leaving a comment* about the missing sensors. ||

==A Special Function==

Most sensors should have this function:

{{{
int PIDGet()
}}}

This function is special, because it returns a bitwise value (1-1024) representing the range of the sensor. This is important for later, because this provides the kind of input the cRIO needs to calculate certain values.

==Analog Sensors==

===!AnalogChannel===

[WPI_Lesson3#AnalogChannel Analog Channel] devices use voltage as a means of measurement. What the voltage range is depends on the sensor being used. Potentiometers, the device most commonly used that falls under this class, have a range of about 0-6 volts.

{{{
float AnalogChannel::GetAverageVoltage()
}}}

==Digital Sensors==

===!DigitalInput===

Devices that use the [WPI_Lesson3#DigitalInput DigitalInput] class return true/false values, as they are all switches of some sort.

{{{
bool DigitalInput::Get()
}}}

===Encoder===

When you are dealing with an [WPI_Lesson3#Encoder encoder], you should think of it as the trip odometer in your car. You use its input to determine if something needs to be done, and how it needs to be done. Should you do something that will only work when a certain value is hit, then you should reset the encoder.

The following functions get the distance (Pulses/set distance) recorded by the encoder, and reset it, respectively.

{{{
float Encoder::GetDistance()
void Encoder::Reset()
}}}

===Accelerometer===

Since [WPI_Lesson3#Accelerometer accelerometers] can measure acceleration on multiple axes, you need to specify the axis that you want to measure off of.

{{{
Accelerometer::GetAcceleration(axis)
}}}

====!GetAcceleration() parameters====

  * `axis`: the `axis` object from within the `Accelerometer` class.
    * `this->kAxis_X`
    * `this->kAxis_Y`
    * `this->kAxis_Z`
  
====!GetAcceleration() use====

Although it may look like an `enum` due to the way it is written, it actually is not. Therefore, the `kAxis_` object passed to the `GetAcceleration()` function needs to be a member of the object you are trying to read from.

{{{
//GetAcceleration example
m_accel->GetAcceleration(m_accel->kAxis_X);
}}}

=Activity=

Find a wiring schematic for a robot that is available right now. Program it so that you can actuate all of the motors, and print all of the sensor inputs to !SmartDashboard. You may optionally print to the driver station as well, but should there be more than 6 sensors available to you, you need to find a way to display the 6 most recently changed sensors.

What is given below is for the 2013 robot.

==Wiring Schematic==

|| *(!) The following section is incomplete.* ||
|| _Reason: complete wiring layout of 2013 robot ||
|| You can help by *leaving a comment* about the missing device mappings. ||

  * Motors with sensors on them
    * Drivetrain
      * Left (`Victor`): PWM 1
      * Right (`Victor`): PWM 2
    * Climber (`Victor`): PWM 3
      * Climb ratchet (`Relay`): Relay 1
    * Feeder (`Victor`): PWM 7
      * Run at full speed on specified button press
    * Plate (2, both `Victor`): PWMs 8,10
  * Sensors
    * Drive encoders
      * Left: channels 1, 2; reversed
      * Right: channels 3, 4
    * Plate potentiometer: channel 1
    * Climber
      * Potentiometer: channel ?
      * Limit switch: channel ?
    * Feeder limit switch: channel ?
  * Control
    * Drive game controller: 1
    * Operator game controller: 2
  * Optional
    * Climb indicator light (`Relay`): Relay ?
      
==Notes==

In order to use the climber, you must use the ratchet properly.
  
  * Extend: Pulse the ratchet forward for .125 seconds, pulse the climber backwards at a value of (-)0.3 for the same period of time, then turn the relay off, and extend the climber.
  * All other states: Pulse the ratchet backwards for .125 seconds, then turn the relay off
  
If you wish to use the climb indicator light, turn it on whenever the climber switch is pressed.

*STOP SCROLLING UNTIL YOU ARE READY TO CHECK YOUR ANSWER*

==Answer==

Answers may vary depending on the robot you are programming for. Ask your mentor to check your work if you are not programming for the robot outlined above.

{{{
//Anything shown above with '?' as an index is not mapped correctly here!

#include "WPILib.h"
#include <cstdlib>
#include <cmath>

class BuiltinDefaultCode: public IterativeRobot
{
public:
  /** BEGIN SECTION: ACTUATORS **/
  
  //Declare a RobotDrive object
  RobotDrive* m_robotDrive
  
  //Declare drive motors
  Victor* m_lDrive;
  Victor* m_rDrive;
  
  //Declare climb actuators
  Victor* m_climb;
  Relay* m_climbRatchet;
  Relay* m_climbLight;
  
  //Declare feeder
  Victor* m_feeder;
  
  //Declare plate motors
  Victor* m_plate1;
  Victor* m_plate2;
  
  /** END SECTION: ACTUATORS **/
  
  /** BEGIN SECTION: SENSORS **/
  
  //Declare drive encoders
  Encoder* m_lEncoder;
  Encoder* m_rEncoder;
  
  //Declare plate potentiometer
  AnalogChannel* m_platePot;
  
  //Declare climbing sensors
  AnalogChannel* m_climbPot;
  DigitalInput* m_climbSwitch;
  
  //Declare feeder switch
  DigitalInput* m_feedSwitch;
  
  /** END SECTION: SENSORS **/
  
  /** BEGIN SECTION: MISCELLANEOUS **/
  
  Timer* m_climbTimer;
  DriverStationLCD* m_dsLCD;
  
  Joystick* m_gamepad1;
  Joystick* m_gamepad2;
  
  int m_ratchetCase;
  
  /** END SECTION: MISCELLANEOUS **/
  
  /** BEGIN SECTION: INIT ROUTINES **/
  
  BuiltinDefaultCode()
  {
    /*** INITIALIZE: ACTUATORS ***/
    
    ///Drive motors
    m_lDrive = new Victor (1);
    m_rDrive = new Victor (2);
    
    ///Drive object
    m_robotDrive = new RobotDrive (m_lDrive, m_rDrive);
    
    ///Climb actuators
    m_climb = new Victor (3);
    m_climbRatchet = new Relay (1);
    m_climbLight = new Relay (2);
    
    ///Feeder
    m_feeder = new Victor (7);
    
    ///Plate motors
    m_plate1 = new Victor (8);
    m_plate2 = new Victor (10);
    
    /*** END INITIALIZATION: ACTUATORS ***/
    
    /*** INITIALIZE: SENSORS ***/
    
    ///Drive encoders
    m_lEncoder = new Encoder (1, 2, true);
    m_lEncoder->SetDistancePerPulse(1);
    m_lEncoder->SetMaxPeriod(1.0);
    m_lEncoder->Start();
    
    m_rEncoder = new Encoder (3, 4, false);
    m_rEncoder->SetDistancePerPulse(1);
    m_rEncoder->SetMaxPeriod(1.0);
    m_lEncoder->Start();
    
    ///Plate potentiometer
    m_platePot = new AnalogChannel (1);
    
    ///Climb sensors
    m_climbPot = new AnalogChannel (2);
    m_climbSwitch = new DigitalInput (5);
    
    //Feeder switch
    m_feedSwitch = new DigitalInput (6);
    
    /*** END INITIALIZATION: SENSORS ***/
    
    /*** INITIALIZE: MISCELLANEOUS ***/
    
    m_climbTimer = new Timer;
    m_dsLCD = DriverStationLCD::GetInstance();
    
    m_gamepad1 = new Joystick (1);
    m_gamepad2 = new Joystick (2);
    
    m_ratchetCase = 0;
    
    /*** END INITIALIZATION: MISCELLANEOUS ***/
  }
  
  void RobotInit()
  {
  }
  
  void DisabledInit()
  {
  }
  
  void AutonomousInit()
  {
  }
  
  void TeleopInit()
  {
  }
  
  /** END SECTION: INIT ROUTINES **/
  
  /** BEGIN SECTION: PERIODIC ROUTINES **/
  
  void DisabledPeriodic()
  {
  }
  
  void AutonomousPeriodic()
  {
  }
  
  void TeleopPeriodic()
  {
    TeleopDriverStationUpdate();
    TeleopSmartDashboardUpdate();
    TeleopDrive();
    TeleopClimb();
    TeleopFeed();
    TeleopPlateControl();
  }
  
  /** END SECTION: PERIODIC ROUTINES **/
  
  /** BEGIN SECTION: ACCESSORY FUNCTIONS **/
  
  void TeleopDriverStationUpdate()
  {
    ///Remember: you can't Printf() a bool. You can Printf() a C string, however.
    char climbMessage [6];
    char feedMessage [6];
    
    if (m_climbSwitch->Get())
      climbMessage = "True";
    else
      climbMessage = "False";
      
    if (m_feedSwitch->Get())
      feedMessage = "True";
    else
      feedMessage = "False";
    
    m_dsLCD->Printf(DriverStationLCD::kUser_Line1,1,"Left Encoder: %f",m_lEncoder->GetDistance());
    m_dsLCD->Printf(DriverStationLCD::kUser_Line2,1,"Right Encoder: %f",m_rEncoder->GetDistance());
    m_dsLCD->Printf(DriverStationLCD::kUser_Line3,1,"Plate Pot: %f",m_platePot->GetAverageVoltage());
    m_dsLCD->Printf(DriverStationLCD::kUser_Line4,1,"Climb Pot: %f",m_climbPot->GetAverageVoltage());
    m_dsLCD->Printf(DriverStationLCD::kUser_Line5,1,"Climb Switch: %s", climbMessage);
    m_dsLCD->Printf(DriverStationLCD::kUser_Line6,1,"Feed Switch: %s", feedMessage);
    
    m_dsLCD->UpdateLCD();
  }
  
  void TeleopSmartDashboardUpdate()
  {
    SmartDashboard::PutNumber("Left Encoder ",m_lEncoder->GetDistance());
    SmartDashboard::PutNumber("Right Encoder ",m_rEncoder->GetDistance());
    SmartDashboard::PutNumber("Plate Pot ",m_platePot->GetAverageVoltage());
    SmartDashboard::PutNumber("Climb Pot ",m_climbPot->GetAverageVoltage());
    SmartDashboard::PutBoolean("Climb Switch ",m_climbSwitch->Get());
    SmartDashboard::PutBoolean("Feed Switch ",m_feedSwitch->Get());
  }
  
  void TeleopDrive()
  {
    float speed,rotation;
    if ((fabs(m_gamepad->GetRawAxis(2)) > 0.2) && (fabs(m_gamepad->GetTawAxis(4)) > 0.2))
    {
	if (m_gamepad->GetRawAxis(2) > 0.0)
	  speed = (m_gamepad->GetRawAxis(2)-0.2)*1.25;
	else
	  speed = (m_gamepad->GetRawAxis(2)+0.2)*1.25;

	if (m_gamepad->GetRawAxis(4) > 0.0)
	  rotation = (-m_gamepad->GetRawAxis(4)-0.2)*1.25;
	else
	  rotation = (-m_gamepad->GetRawAxis(4)+0.2)*1.25;

	m_robotDrive->ArcadeDrive(speed,rotation);
    }
  }
  
  void TeleopClimb()
  {
    if (m_gamepad1->GetRawAxis(5) > 0.2)
	    extendClimber(m_gamepad1->GetRawAxis(5));
    else if (m_Gamepad1->GetRawAxis(5) < -0.2)
	    retractClimber((-m_gamepad1->GetRawAxis(5)+0.2)*0.75);
    else
	    retractClimber(0.0);
  }
  
  void TeleopFeed()
  {
    if (m_gamepad2->GetRawAxis(3) < -0.4)
      m_feeder->Set(m_gamepad2->GetRawAxis(3));		//This will just make the feeder run at varying speeds based on the trigger. Any negative value should do.
    else
      m_feeder->Set(0.0);
  }
  
  void TeleopPlateControl()
  {
    if (fabs(m_gamepad2->GetRawAxis(2)) > 0.2)
    {
      if (m_gamepad2->GetRawAxis(2)) > 0.0)
	plateSet((m_gamepad2->GetRawAxis(2) - 0.2)*1.25);
      else
	plateSet((m_gamepad2->GetRawAxis(2) + 0.2)*1.25);
    }
    else
      plateSet(0.0);
  }
  
  void lockClimber()
  {
    m_climbRatchet->Set(Relay::kReverse);
  }
  
  void unlockClimber()
  {
    m_climbRatchet->Set(Relay::kForward);
    m_climb->Set(-0.3);
  }
  
  void extendClimber(float speed)
  {
    switch (m_ratchetCase)
    {
      case 0:
	m_climbTimer->Stop();
	m_climbTimer->Start();
	m_climbTimer->Reset();
	unlockClimber();
	m_ratchetCase++;
	break;
      case 1:
	if (m_climbTimer->HasPeriodPassed(0.125))
	  m_ratchetCase++;
	break;
      case 2:
	m_climbRatchet->Set(Relay::kOff);
	m_climbTimer->Stop();
	m_climb->Set(speed);
	m_ratchetCase++;
	break;
      case 3:
	m_climb->Set(speed);
	break;
      default:
	m_ratchetCase = 0;
    }
  }
  
  void retractClimber(float speed)
  {
    switch (m_ratchetCase)
    {
      case 4:
	m_climbTimer->Stop();
	m_climbTimer->Start();
	m_climbTimer->Reset();
	lockClimber();
	m_climb->Set(speed);
	m_ratchetCase++;
	break;
      case 5:
	if (m_climbTimer->HasPeriodPassed(0.125))
	  m_ratchetCase++;
	m_climb->Set(speed);
	break;
      case 6:
	m_climbRatchet->Set(Relay::kOff);
	m_climb->Set(speed);
	break;
      default:
	m_ratchetCase = 4;
    }
  }
  
  void plateSet(float speed)
  {
    m_plate1->Set(speed);
    m_plate2->Set(speed);
  }
}
}}}

|| ← [WPI_Lesson6 Chapter 2: Driving and User Input - Lesson 6: Earning Your Driver's License: Driving] || *Lesson 7* || [WPI_Lesson8 Lesson 8: Concepts of the PID] → ||